'''
Basic operation not based on tensorflow

Updated on 2017.07.31
Author : Yeonwoo Jeong
'''
import matplotlib.pyplot as plt
import numpy as np
import imageio
import os

class struct:
    def __str__ (self):
        '''
        Usage :
            Var = struct()
            Var.A = B
            print(Var)
        '''
        return "struct{\n    "+"\n   ".join(["{} : {}".format(key, vars(self)[key]) for key in vars(self).keys()]) + "\n}"

def create_dir(dirname):
    if not os.path.exists(dirname):
        os.makedirs(dirname)

def make_gif(images_path, gif_path):
    '''
    Args:
        images_path - list of string
            images path should be ordered
        gif_path - string
            gif_path to be installed
    '''
    with imageio.get_writer(gif_path, mode='I') as writer:
        for image_path in images_path:
            image = imageio.imread(image_path)
            writer.append_data(image)

def show_gray_image(ax, image):
    '''
    show image with grayscale
    Arg:
        ax - <matplotlib.axes._subplots>
            generated by
                    fig = plt.figure()
                    ax = fig.add_subplot()
        image - 2D or 3D image
    '''
    gray_image = np.average(image, axis=2) if len(image.shape) == 3 else image
    ax.imshow(gray_image, cmap = 'gray')
    ax.set_axis_off()

def show_gray_image_3d(gr_img_3d, col = 5, figsize = (5, 5), dataformat = 'HWC'):
    '''
    show 3d gray image
    Args:
        gr_img_3d - numpy 3D
            shape should follow dataformat
        col - int
            defaults to be 5
            The number of pictures appear on
        fig_size - tuple(2 elements)
            defaults to be (5,5) size of figure

        dataformat - 'HWC' or 'CHW'
            'HWC' for [height, width, channel]
            'CHW' for [channel,height, width]
    Return
        fig
    '''
    assert dataformat == 'HWC' or dataformat == "CHW", "Dataformat should be HWC for CHW"
    if dataformat == 'CHW':
        gr_img_3d = np.transpose(gr_img_3d, axes=[1,2,0])
    height, width, channel = gr_img_3d.shape
    fig = plt.figure(figsize = figsize, edgecolor = 'k')
    row = np.ceil(channel/col)
    for channel_ in range(channel):
        show_gray_image(fig.add_subplot(row, col, channel_+1), gr_img_3d[:,:,channel_])
    return fig
